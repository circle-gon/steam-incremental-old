{"version":3,"file":"index.a1b182f9.js","sources":["../../vite/modulepreload-polyfill","../../src/stores/main/utils.ts","../../src/stores/classes/trackers.ts","../../src/stores/classes/upgrades.ts","../../src/stores/main/types.ts","../../src/stores/main/queue-gpt.ts","../../src/stores/classes/resource.ts","../../src/stores/steam.ts","../../src/stores/main/tabTypes.ts","../../src/stores/tabs.ts","../../src/stores/notifications.ts","../../src/stores/classes/achievements.ts","../../src/stores/main/tabs.ts","../../src/stores/stats.ts","../../src/stores/main.ts","../../src/stores/main/compUtils.ts","../../src/components/generic/TabsView.vue","../../plugin-vue:export-helper","../../src/components/generic/UpgradeButton.vue","../../src/components/subtabs/SteamSubtab.vue","../../src/components/main/BusinessTab.vue","../../src/components/main/DisplayView.vue","../../src/components/main/StatsTab.vue","../../src/components/main/LoreTab.vue","../../src/components/generic/SettingButtonInput.vue","../../src/components/subtabs/SettingsSubtab.vue","../../src/components/main/OptionsTab.vue","../../src/components/main/AchieveTab.vue","../../src/components/main/NotificationView.vue","../../src/components/main/ModalView.vue","../../src/App.vue","../../src/main.ts"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","import type {\n  GenericObjectType,\n  GenericObjectTypeType,\n  BasicType,\n} from './types';\nimport { isInputTypeArray, isInputTypeObject, isInputType } from './typeUtils';\n// number display\nconst displayNumber = function (what: number, prec = 2, overide = false) {\n  // if number is interger, display it as whole\n  if (Number.isInteger(what)) {\n    return what.toString();\n  } else if (what < 1e9) {\n    if (what > 1e3) {\n      return what.toLocaleString('en-US');\n    } else if (Number.isInteger(what * 10) && !overide) {\n      return what.toFixed(1);\n    } else {\n      return what.toFixed(prec);\n    }\n  } else {\n    return what.toExponential(prec);\n  }\n};\n// time formatting\nconst prettyTimeAsTotal = function (data: number) {\n  const hours = Math.floor(data / 1000 / 60 / 60);\n  const minutes = Math.floor(data / 1000 / 60 - hours * 60);\n  const seconds = (data / 1000 - hours * 3600 - minutes * 60).toFixed(2);\n  return `Hours: ${hours}, minutes: ${minutes}, seconds: ${seconds}`;\n};\n// util functions\nconst getTime = function () {\n  return Date.now();\n};\nfunction getTimePassed(time: number) {\n  return (getTime() - time) / 1000;\n}\nconst isUndef = function <T>(item: T | undefined) {\n  return item === undefined;\n};\nconst R = function <Type, OtherType>(\n  item: Type | undefined,\n  replacer: OtherType\n) {\n  return item !== undefined ? item : replacer;\n};\nconst getFullType = function (obj: unknown, showFullClass: boolean) {\n  // get toPrototypeString() of obj (handles all types)\n  if (showFullClass && typeof obj === 'object') {\n    return Object.prototype.toString.call(obj);\n  }\n  if (obj == null) {\n    return (obj + '').toLowerCase();\n  } // implicit toString() conversion\n  const deepType = Object.prototype.toString\n    .call(obj)\n    .slice(8, -1)\n    .toLowerCase();\n  if (deepType === 'generatorfunction') {\n    return 'function';\n  }\n\n  // Prevent overspecificity (for example, [object HTMLDivElement], etc).\n  // Account for functionish Regexp (Android <=2.3), functionish <object> element (Chrome <=57, Firefox <=52), etc.\n  // String.prototype.match is universally supported.\n\n  return deepType.match(\n    /^(array|bigint|date|error|function|generator|regexp|symbol)$/\n  )\n    ? deepType\n    : typeof obj === 'object' || typeof obj === 'function'\n    ? 'object'\n    : typeof obj;\n};\nexport function isObject(obj: unknown): obj is object {\n  return obj !== null && typeof obj === 'object';\n}\nfunction keyIsObject(\n  obj: object,\n  key: string | number | symbol\n): key is keyof typeof obj {\n  const val = obj[key as keyof typeof obj];\n  return isObject(val);\n}\n\nconst deepReplace = function mergeDeep<T extends Q, Q extends object>(\n  target: T,\n  source: Q,\n  modifier: (target: unknown, source: unknown, key: string) => boolean = () =>\n    false\n): T {\n  if (isObject(target) && isObject(source)) {\n    console.log('trigger');\n    for (const key in source) {\n      if (!Object.prototype.hasOwnProperty.call(source, key)) continue;\n      if (modifier(target, source, key)) continue;\n      console.log(key);\n      //debugger;\n      if (keyIsObject(source, key)) {\n        mergeDeep(target[key], source[key], modifier);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n        console.log(target);\n      }\n    }\n  }\n\n  return target;\n};\nconst copy = function (v: GenericObjectType, keys: string[], isInclude = true) {\n  const r: GenericObjectType = {};\n  for (const k in v) {\n    if (\n      Object.hasOwn(v, k) &&\n      (isInclude ? keys.includes(k) : !keys.includes(k))\n    ) {\n      r[k] = v[k];\n    }\n  }\n  return r;\n};\nexport {\n  displayNumber,\n  prettyTimeAsTotal,\n  getTime,\n  isUndef,\n  R,\n  copy,\n  getTimePassed,\n  getFullType,\n  deepReplace,\n};\n","// a stat tracker for tracking resources and\n// their values\n// does require resources list to equal obj[res]\n// ie. \"steam\" -> obj.steam\nimport type { TrackType, ContentType, StatTrackerType } from \"../main/types\";\nclass StatTracker implements StatTrackerType {\n  resList: string[];\n  resources: TrackType;\n  constructor(resources: string[]) {\n    this.resList = resources;\n    this.resources = {};\n    for (const res of resources) {\n      this.resources[res] = { totalMade: 0, currentAmt: 0 };\n    }\n  }\n\n  update(content: ContentType) {\n    for (const res of this.resList) {\n      const owned = content[res].owned;\n      const currentAmt = this.resources[res].currentAmt;\n      if (owned > currentAmt) {\n        this.resources[res].totalMade += owned - currentAmt;\n      }\n      this.resources[res].currentAmt = owned;\n    }\n  }\n}\nexport { StatTracker };\n","// upgrades n stuff for most of the game\nimport { R } from \"../main/utils\";\nimport { useSteamStore } from \"../main\";\nimport type {\n  ConfigType,\n  UpgradeType,\n  OneTimeUpgradeType,\n  OneTimeConfigType,\n  UpgradeDataType,\n  CoreConfigType,\n} from \"../main/types\";\n\nconst basicConfig: CoreConfigType = { layer: Infinity, data: { show: false } };\nclass Upgrades implements UpgradeType {\n  name: string;\n  desc: string;\n  getPrice: (level: number) => number;\n  getEffect: (level: number) => number;\n  isUnlocked: () => boolean;\n  layer: number;\n  level: number;\n  maxLevel: number;\n  data: UpgradeDataType;\n  constructor(\n    name: string,\n    desc: string,\n    getPrice: (level: number) => number,\n    getEffect: (level: number) => number,\n    isUnlocked: () => boolean,\n    config: ConfigType = basicConfig\n  ) {\n    this.name = name;\n    this.desc = desc;\n    this.level = 0;\n    this.getPrice = getPrice;\n    this.getEffect = getEffect;\n    this.isUnlocked = isUnlocked;\n    this.layer = config.layer;\n    this.data = config.data;\n    this.maxLevel = R(config.maxLevel, Infinity);\n  }\n\n  getCurrentPrice() {\n    return this.getPrice(this.level);\n  }\n\n  getPriceDisplay() {\n    return this.getCurrentPrice() + \" \" + this.getResource();\n  }\n\n  isMaxLevel() {\n    return this.level === this.maxLevel;\n  }\n\n  hasBought() {\n    return this.level > 0;\n  }\n\n  getStore() {\n    let curr: { owned: number } = { owned: 0 };\n    switch (this.layer) {\n      case 1:\n        curr = useSteamStore().steam;\n        break;\n      default:\n        break;\n    }\n    return curr;\n  }\n\n  getResource() {\n    const res = \"steam\";\n    switch (this.layer) {\n      default:\n        break;\n    }\n    return res;\n  }\n\n  isUnbuyable() {\n    const res = this.getStore();\n    if (this.isMaxLevel()) return true;\n    return res.owned < this.getCurrentPrice();\n  }\n\n  buy() {\n    const store = this.getStore();\n    const price = this.getCurrentPrice();\n    if (price <= this.getStore().owned && !this.isMaxLevel()) {\n      switch (this.layer) {\n        case 1:\n          store.owned -= price;\n          break;\n        default:\n          break;\n      }\n      this.level++;\n    }\n  }\n\n  static use(upg: UpgradeType) {\n    return upg.getEffect(upg.level);\n  }\n}\nclass OneTimeUpgrades extends Upgrades implements OneTimeUpgradeType {\n  getPrice: () => number;\n  getEffect: () => number;\n  constructor(\n    name: string,\n    desc: string,\n    getPrice: number,\n    getEffect: number,\n    isUnlocked: () => boolean,\n    config: OneTimeConfigType = basicConfig\n  ) {\n    super(\n      name,\n      desc,\n      () => getPrice,\n      () => getEffect,\n      isUnlocked,\n      config\n    );\n    this.getPrice = () => getPrice;\n    this.getEffect = () => getEffect;\n    this.maxLevel = 1;\n  }\n  getCurrentPrice() {\n    return this.getPrice();\n  }\n  static use(upg: OneTimeUpgradeType) {\n    return upg.isMaxLevel() ? upg.getEffect() : 0;\n  }\n}\nexport { OneTimeUpgrades, Upgrades };\n","import type { TabOptionsType, InnerTabOptionsType } from \"./tabTypes\";\n\n// util types\nexport type FilteredKeys<T, U> = {\n  [P in keyof T]: T[P] extends U ? P : never;\n}[keyof T];\nexport function isOfType<T>(test: T, prop: keyof T): test is T {\n  return (test as T)[prop] !== undefined;\n}\n\n// unexported types\ninterface CoreUpgradeType {\n  name: string;\n  desc: string;\n  isUnlocked: () => boolean;\n  layer: number;\n  level: number;\n  maxLevel: number;\n  isUnbuyable: () => boolean;\n  getCurrentPrice: () => number;\n  getPriceDisplay: () => string;\n  isMaxLevel: () => boolean;\n  getStore: () => { owned: number };\n  getResource: () => string;\n  buy: () => void;\n  hasBought: () => boolean;\n  data: UpgradeDataType;\n}\ninterface CoreTabsType {\n  display: string;\n  actual: string;\n  shown: () => boolean;\n  lore?: LoreType[];\n  buttons?: Array<RealSettingButtonType | undefined>[];\n}\nexport type SteamResourceType = \"heat\" | \"water\" | \"fill\";\nexport interface AchievementType {\n  desc: string;\n  hoverText: string;\n  img: string;\n  isUnlocked: () => boolean;\n  bonus: number;\n}\nexport interface ResourceType {\n  owned: number;\n  multi: number;\n  update: () => void;\n  addNewQueue: (drain: number) => void;\n  queueData?: {\n    req: number;\n    k: number;\n    c: number;\n    queue: QueueType[];\n    gainPerTick: GainType;\n    sideEffect: (diff: number) => void;\n    canDo: () => boolean;\n  };\n  isEmpty: (shouldEmpty?: boolean) => boolean;\n  isNotFull: boolean;\n}\nexport type UpgradeDataType =\n  | { show: false }\n  | { show: true; getBonus: () => string };\nexport type GainType = (data: QueueType) => number;\nexport type ResourceQueueType = Required<ResourceType>;\nexport interface ResourceInputType {\n  owned?: number;\n  multi?: number;\n  req?: number;\n  k?: number;\n  c?: number;\n  gainPerTick?: GainType;\n  sideEffect?: (diff: number) => void;\n  canDo?: () => boolean;\n}\nexport interface QueueType {\n  remain: number;\n  onStart: number;\n  time: number;\n  drainFactor: number;\n  c: number;\n  lastRemain: number;\n  manual: boolean;\n}\nexport interface CoreConfigType {\n  layer: number;\n  data: UpgradeDataType;\n}\nexport interface ConfigType extends CoreConfigType {\n  maxLevel?: number;\n}\nexport type OneTimeConfigType = CoreConfigType;\nexport interface UpgradeType extends CoreUpgradeType {\n  getPrice: (level: number) => number;\n  getEffect: (level: number) => number;\n}\nexport interface OneTimeUpgradeType extends CoreUpgradeType {\n  getPrice: () => number;\n  getEffect: () => number;\n}\nexport interface GenericObjectType {\n  [key: string]: BasicType;\n}\nexport type GenericArrayType = BasicType[];\nexport type GenericObjectTypeType = GenericArrayType | GenericObjectType;\nexport type BasicType =\n  | string\n  | number\n  | boolean\n  | { [key: string]: BasicType }\n  | BasicType[];\nexport interface OneTimeSteamUpgradeType {\n  stronger: OneTimeUpgradeType;\n  auto: OneTimeUpgradeType;\n}\nexport interface TrackType {\n  [key: string]: {\n    totalMade: number;\n    currentAmt: number;\n  };\n}\nexport interface ContentType {\n  [key: string]: {\n    owned: number;\n  };\n}\nexport interface StatTrackerType {\n  resList: string[];\n  resources: TrackType;\n  update: (content: ContentType) => void;\n}\nexport interface InnerTabsType extends CoreTabsType {\n  actual: InnerTabOptionsType;\n}\nexport interface TabsType extends CoreTabsType {\n  actual: TabOptionsType;\n  subtabs: InnerTabsType[] | [];\n}\nexport interface InputType {\n  min: number;\n  max: number;\n  getValue: () => number;\n  result: (r: number) => number;\n}\nexport interface LoreType {\n  text: string;\n  unlocked: () => boolean;\n  textRequire: string;\n}\nexport interface SettingButtonType {\n  type: \"button\";\n  display: () => string | null;\n  do: () => void;\n}\nexport interface SettingButtonInputType {\n  type: \"input\";\n  display: () => string | null;\n  doInput: (value: number) => void;\n  other: InputType;\n}\nexport type RealSettingButtonType = SettingButtonType | SettingButtonInputType;\n\nexport interface NotificationType {\n  text: string;\n  time: number;\n}\n","import type { QueueType } from \"./types\";\nimport { getTimePassed } from \"./utils\";\n\nfunction upThenDown(data: QueueType) {\n  return (\n    ((data.onStart * (data.c + 1)) / data.c) *\n    (1 -\n      1 /\n        (1 + data.c * Math.E ** (-data.drainFactor * getTimePassed(data.time))))\n  );\n}\n\nfunction linear(data: QueueType) {\n  return (\n    data.onStart *\n    (1 - (getTimePassed(data.time) * data.drainFactor) / data.c ** 1.05)\n  );\n}\n\nexport { linear, upThenDown };\n","import { R, getTime } from \"../main/utils\";\nimport type {\n  ResourceInputType,\n  QueueType,\n  ResourceType,\n  GainType,\n} from \"../main/types\";\nimport { isOfType } from \"../main/types\";\nimport { upThenDown as defaultQueue } from \"../main/queue-gpt\";\nclass Resource implements ResourceType {\n  owned: number;\n  multi: number;\n  queueData?: {\n    req: number;\n    k: number;\n    c: number;\n    queue: QueueType[];\n    gainPerTick: GainType;\n    sideEffect: (diff: number) => void;\n    canDo: () => boolean;\n  };\n  constructor(obj: ResourceInputType = {}) {\n    this.owned = R(obj.owned, 0);\n    this.multi = R(obj.multi, 1);\n    // req to max\n    // left to drain\n    if (obj.req !== undefined) {\n      this.queueData = {\n        req: obj.req,\n        k: 1,\n        c: 5,\n        queue: [],\n        gainPerTick:\n          obj.gainPerTick !== undefined ? obj.gainPerTick : defaultQueue,\n        sideEffect:\n          obj.sideEffect !== undefined\n            ? obj.sideEffect\n            : () => {\n                return undefined;\n              },\n        canDo: obj.canDo !== undefined ? obj.canDo : () => true,\n      };\n    }\n  }\n\n  addNewQueue(drainAmt: number, manual = true) {\n    if (this.queueData) {\n      this.queueData.queue.push({\n        remain: drainAmt,\n        onStart: drainAmt,\n        time: getTime(),\n        drainFactor: this.queueData.k,\n        c: this.queueData.c,\n        lastRemain: 0,\n        manual: manual,\n      });\n    }\n  }\n\n  get isNotFull() {\n    if (this.queueData) {\n      return this.owned < this.queueData.req;\n    }\n    throw new Error(\n      \"Can not perform isFull on Resource that does not have queueData\"\n    );\n  }\n\n  isEmpty(notFull = true) {\n    if (this.queueData) {\n      return (\n        (notFull ? this.isNotFull : true) &&\n        this.queueData.queue.find((element) => {\n          return element.manual === true;\n        }) === undefined\n      );\n    }\n    throw new Error(\n      \"Can not perform isEmpty on Resource that does not have queueData\"\n    );\n  }\n\n  update() {\n    if (this.queueData) {\n      for (const [num, data] of this.queueData.queue.entries()) {\n        if (isOfType<QueueType>(data, \"c\") && this.queueData.canDo()) {\n          data.lastRemain = data.remain;\n          data.remain = this.queueData.gainPerTick(data);\n          // (c+1)/c because of start errors\n          // now todo: figure out c and k's effect on result\n          const diff = data.lastRemain - data.remain;\n          this.owned += diff;\n          this.queueData.sideEffect(diff);\n          if (this.owned > this.queueData.req) {\n            this.queueData.queue = [];\n            this.owned = this.queueData.req;\n          } else if (data.remain < 0.01) {\n            this.owned += data.remain;\n            this.queueData.sideEffect(data.remain);\n            this.queueData.queue.splice(num, 1);\n          }\n        }\n      }\n    }\n  }\n}\nexport { Resource };\n","import { defineStore } from 'pinia';\nimport { Resource } from './classes/resource';\nimport type {\n  ResourceQueueType,\n  SteamResourceType,\n  QueueType,\n} from './main/types';\nimport { isOfType } from './main/types';\nimport { StatTracker } from './classes/trackers';\nimport { OneTimeUpgrades } from './classes/upgrades';\nimport { linear, upThenDown } from './main/queue-gpt';\n\nconst baseConfigFactory = function () {\n  return { layer: 1, data: { show: false } } as const;\n};\nconst autoCap = 0.4;\nexport const useSteamStore = defineStore('steam', {\n  state: () => ({\n    steam: new Resource(),\n    water: new Resource({\n      owned: 10,\n      req: 1e100, // absurd big number to solve problems\n    }) as ResourceQueueType,\n    heat: new Resource({ req: 1 }) as ResourceQueueType,\n    fill: new Resource({ req: 1 }) as ResourceQueueType,\n    isDoing: false,\n    statTracker: new StatTracker(['steam']),\n    oneUpgrades: {\n      stronger: new OneTimeUpgrades(\n        'Getting stronger!',\n        'Multiplies speed of all resources by 2',\n        1,\n        1,\n        () => true,\n        baseConfigFactory()\n      ),\n      auto: new OneTimeUpgrades(\n        'Make a Rube Goldberg machine',\n        'Automaticially fills the furnace based on your steam',\n        3,\n        1,\n        () => false,\n        baseConfigFactory()\n      ),\n      help: new OneTimeUpgrades(\n        \"Welp, that wasn't fun\",\n        'Changes water gain formula from m/(1 + ce^(-kx)) (gain goes up and down) to linear',\n        15,\n        1,\n        () => false,\n        baseConfigFactory()\n      ),\n    },\n  }),\n  getters: {\n    isUseable(store) {\n      return (innerRes: SteamResourceType) => {\n        return !store.isDoing && store[innerRes].isEmpty();\n      };\n    },\n    autoFurnaceMulti(store) {\n      return Math.min((store.steam.owned + 1) ** 0.5 / 10, autoCap);\n    },\n  },\n  actions: {\n    init() {\n      const auto = this.oneUpgrades.auto;\n      auto.isUnlocked = () => {\n        return this.oneUpgrades.stronger.hasBought();\n      };\n      this.oneUpgrades.help.isUnlocked = () => {\n        return auto.hasBought();\n      };\n      this.fill.queueData.sideEffect = (diff: number) => {\n        this.water.owned -= diff;\n      };\n      this.fill.queueData.canDo = () => {\n        return this.water.owned > 0;\n      };\n      this.water.queueData.gainPerTick = (data: QueueType) => {\n        const gain = (\n          OneTimeUpgrades.use(this.oneUpgrades.help) ? linear : upThenDown\n        )(data);\n        return gain;\n      };\n      auto.data.show = true;\n      if (auto.data.show) {\n        auto.data.getBonus = () => {\n          return (\n            (this.autoFurnaceMulti * 100).toFixed(0) +\n            '%' +\n            (this.autoFurnaceMulti === autoCap ? ' (capped)' : '')\n          );\n        };\n      }\n    },\n    updateResources(delta: number) {\n      const isDoingAttr = [];\n      for (const value of Object.values(this)) {\n        if (isOfType<ResourceQueueType>(value, 'queueData')) {\n          value.update();\n          isDoingAttr.push(value.isEmpty(false));\n        }\n      }\n      this.isDoing = isDoingAttr.includes(false);\n      if (OneTimeUpgrades.use(this.oneUpgrades.auto)) {\n        const multi = this.autoFurnaceMulti / 1000;\n        if (this.heat.isNotFull && this.heat.queueData.canDo()) {\n          const result = this.heat.multi * multi * delta;\n          this.heat.owned += result;\n          this.heat.queueData.sideEffect(result);\n        }\n        if (this.fill.isNotFull && this.fill.queueData.canDo()) {\n          let result = this.fill.multi * multi * delta;\n          result = result > this.water.owned ? this.water.owned : result;\n          this.fill.owned += result;\n          this.fill.queueData.sideEffect(result);\n        }\n      }\n    },\n    getResource(res: SteamResourceType) {\n      const value = this[res];\n      if (\n        this.isUseable(res) &&\n        (res === 'fill' ? this.fill.queueData.canDo() : true)\n      ) {\n        value.addNewQueue(value.multi);\n      }\n    },\n    updateMulti() {\n      this.heat.multi = 1 + OneTimeUpgrades.use(this.oneUpgrades.stronger);\n      this.fill.multi = 1 + OneTimeUpgrades.use(this.oneUpgrades.stronger);\n      this.water.multi = 1 + OneTimeUpgrades.use(this.oneUpgrades.stronger);\n    },\n    updateFurnace() {\n      if (\n        this.fill.owned >= this.fill.queueData.req &&\n        this.heat.owned >= this.heat.queueData.req\n      ) {\n        this.fill.owned -= this.fill.queueData.req;\n        this.heat.owned -= this.heat.queueData.req;\n        this.steam.owned += this.steam.multi;\n      }\n    },\n    update(delta: number) {\n      this.updateMulti();\n      this.updateResources(delta);\n      this.updateFurnace();\n      this.statTracker.update({ steam: this.steam });\n    },\n  },\n});\n","export const BUSINESS_TAB_LIST = [\"workers\", \"steam\"] as const;\nexport type BUSINESS_TAB_LIST_TYPE = Record<\n  typeof BUSINESS_TAB_LIST[number],\n  object\n>;\nexport type MAIN_TAB_LIST_TYPE = Record<TabOptionsType, object>;\nexport const OPTIONS_TAB_LIST = [\"settings\", \"about\", \"changelog\"] as const;\nexport type OPTIONS_TAB_LIST_TYPE = Record<\n  typeof OPTIONS_TAB_LIST[number],\n  object\n>;\nexport type InnerTabKeysType = keyof InnerTabOptionsListType;\nexport type InnerTabOptionsType =\n  | keyof BUSINESS_TAB_LIST_TYPE\n  | keyof OPTIONS_TAB_LIST_TYPE;\nexport type TabOptionsType = InnerTabKeysType | \"lore\" | \"stats\" | \"achieve\";\nexport type InnerTabOptionsListType = {\n  business: keyof BUSINESS_TAB_LIST_TYPE;\n  options: keyof OPTIONS_TAB_LIST_TYPE;\n};\n","import { defineStore } from \"pinia\";\nimport type {\n  TabOptionsType,\n  InnerTabOptionsListType,\n  InnerTabKeysType,\n  BUSINESS_TAB_LIST_TYPE as BSTYPE,\n  OPTIONS_TAB_LIST_TYPE as OSTYPE,\n} from \"./main/tabTypes\";\nimport {\n  BUSINESS_TAB_LIST as BS,\n  OPTIONS_TAB_LIST as OS,\n} from \"./main/tabTypes\";\n\nexport const useTabsStore = defineStore(\"tabs\", {\n  state: () => ({\n    tab: \"business\" as TabOptionsType,\n    innerTabs: {\n      business: \"steam\",\n      options: \"settings\",\n    } as InnerTabOptionsListType,\n  }),\n  actions: {\n    changeInnerTab(to: string) {\n      function isCertainStr<T extends string>(\n        str: string,\n        tlist: Readonly<T[]>\n      ): str is T {\n        return tlist.includes(str as T);\n      }\n      const isInInnerTabs = (otab: string): otab is InnerTabKeysType => {\n        return otab in this.innerTabs;\n      };\n      if (!isInInnerTabs(this.tab))\n        throw new Error(\n          `Invalid mutation of store: tab ${this.tab} does not have a inner tab.`\n        );\n      else if (this.tab === \"business\") {\n        if (!isCertainStr<keyof BSTYPE>(to, BS))\n          throw new Error(`Invalid inner tab setting: ${to}.`);\n        this.innerTabs[this.tab] = to;\n      } else if (this.tab === \"options\") {\n        if (!isCertainStr<keyof OSTYPE>(to, OS))\n          throw new Error(`Invalid inner tab setting: ${to}.`);\n        this.innerTabs[this.tab] = to;\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _checkedAll: never = this.tab;\n        throw new Error(`Tab ${this.tab} does not have a inner tab.`);\n      }\n    },\n  },\n});\n","import { defineStore } from \"pinia\";\nimport type { NotificationType } from \"./main/types\";\n\nexport const useNotificationStore = defineStore(\"notifications\", {\n  state: () => ({\n    notifications: [] as NotificationType[],\n  }),\n  actions: {\n    updateNotifications() {\n      for (const [num, notify] of this.notifications.entries()) {\n        if (Date.now() - notify.time > 5000) {\n          this.removeNotify(num);\n        }\n      }\n    },\n    notify(text: string) {\n      this.notifications.push({\n        text: text,\n        time: Date.now(),\n      });\n    },\n    removeNotify(id: number) {\n      this.notifications.splice(id, 1);\n    },\n  },\n});\n","import type { AchievementType } from \"../main/types\";\n\nclass Achievement implements AchievementType {\n  desc: string;\n  hoverText: string;\n  img: string;\n  isUnlocked: () => boolean;\n  bonus: number;\n  constructor(\n    desc: string,\n    hoverText: string,\n    img: string,\n    isUnlocked: () => boolean,\n    bonus: number\n  ) {\n    this.desc = desc;\n    this.hoverText = hoverText.replace(\n      \"[kPoints]\",\n      bonus + \" knowledge points\"\n    );\n    this.img = img;\n    this.isUnlocked = isUnlocked;\n    this.bonus = bonus;\n  }\n}\nexport { Achievement };\n","import type { TabsType, AchievementType } from \"./types\";\nimport { useSteamStore, useStore } from \"../main\";\nimport { Achievement } from \"../classes/achievements\";\n\nconst ACHIEVEMENTS: AchievementType[][] = [\n  [\n    new Achievement(\n      \"Work\",\n      \"Get one steam. Reward: [kPoints].\",\n      \"fake url\",\n      function () {\n        const store = useSteamStore();\n        return store.statTracker.resources.steam.totalMade > 0;\n      },\n      5\n    ),\n  ],\n];\nconst TABS: TabsType[] = [\n  {\n    display: \"Business\",\n    actual: \"business\",\n    subtabs: [\n      {\n        display: \"Steam\",\n        actual: \"steam\",\n        shown() {\n          return true;\n        },\n      },\n      {\n        display: \"Workers\",\n        actual: \"workers\",\n        shown() {\n          //      return get(state, \"steam\",\"steam\").totalMade >= 10\n          return true;\n        },\n      },\n    ],\n    shown() {\n      return true;\n    },\n  },\n  {\n    display: \"Stats\",\n    actual: \"stats\",\n    shown() {\n      return true;\n    },\n    subtabs: [],\n  },\n  {\n    display: \"Achievements\",\n    actual: \"achieve\",\n    shown() {\n      return true;\n    },\n    subtabs: [],\n  },\n  {\n    display: \"Lore\",\n    actual: \"lore\",\n    lore: [\n      {\n        text: \"You were bored, so you decided to make some steam using a hot pot you had at home.\",\n        unlocked() {\n          const store = useSteamStore();\n          return store.statTracker.resources.steam.totalMade > 0;\n        },\n        textRequire: \"Get 1 Steam\",\n      },\n      {\n        text: \"Trying to fill water and heat back and forth isn't really efficent, so you invented upgrades.\",\n        unlocked() {\n          const store = useSteamStore();\n          return store.statTracker.resources.steam.totalMade >= 5;\n        },\n        textRequire: \"Get 5 Steam\",\n      },\n    ],\n    shown() {\n      return true;\n    },\n    subtabs: [],\n  },\n  {\n    display: \"Options\",\n    actual: \"options\",\n    subtabs: [\n      {\n        display: \"Settings\",\n        actual: \"settings\",\n        shown() {\n          return true;\n        },\n      },\n      {\n        display: \"About\",\n        actual: \"about\",\n        shown() {\n          return true;\n        },\n      },\n      {\n        display: \"Changelog\",\n        actual: \"changelog\",\n        shown() {\n          return true;\n        },\n      },\n    ],\n    buttons: [\n      [\n        {\n          type: \"button\",\n          display: () => \"Save game\",\n          do: () => {\n            const store = useStore();\n            store.saveGame();\n          },\n        },\n        {\n          type: \"button\",\n          display: () => \"Export save\",\n          do: () => {\n            const store = useStore();\n            store.internals.save = store.getSave;\n          },\n        },\n        {\n          type: \"button\",\n          display: () => \"Import save\",\n          do: () => {\n            const store = useStore();\n            store.loadSave();\n          },\n        },\n      ],\n      [\n        {\n          type: \"input\",\n          display() {\n            return \"Save interval: \" + this.other.getValue() + \" secs\";\n          },\n          doInput(value: number) {\n            const store = useStore();\n            store.settings.saveInterval = value;\n          },\n          other: {\n            min: 10,\n            max: 60,\n            getValue() {\n              const store = useStore();\n              return store.settings.saveInterval / 1000;\n            },\n            result(data: number) {\n              return data * 1000;\n            },\n          },\n        },\n        {\n          type: \"input\",\n          display() {\n            return \"Game loop rate: \" + this.other.getValue() + \" ms\";\n          },\n          doInput(value: number) {\n            const store = useStore();\n            store.settings.maxFPS = value;\n          },\n          other: {\n            min: 16,\n            max: 900,\n            getValue() {\n              const store = useStore();\n              return parseInt((1000 / store.settings.maxFPS).toFixed(0));\n            },\n            result(data: number) {\n              return 1000 / data;\n            },\n          },\n        },\n        {\n          type: \"button\",\n          display: () => {\n            const store = useStore();\n            return (store.settings.displayFPS ? \"Hide\" : \"Display\") + \" FPS\";\n          },\n          do: () => {\n            const store = useStore();\n            store.settings.displayFPS = !store.settings.displayFPS;\n          },\n        },\n      ],\n      [\n        undefined,\n        {\n          type: \"button\",\n          display: () => \"HARD RESET\",\n          do: () => {\n            const store = useStore();\n            store.hardReset();\n          },\n        },\n      ],\n    ],\n    shown() {\n      return true;\n    },\n  },\n];\nexport { TABS, ACHIEVEMENTS };\n","import { defineStore } from \"pinia\";\nimport { ACHIEVEMENTS } from \"./main/tabs\";\n\nfunction getIdFromData(row: number, col: number) {\n  return row.toString() + col.toString();\n}\nexport const useStatsStore = defineStore(\"stats\", {\n  state: () => ({\n    totalTimePlayed: 0,\n    // may replace with store\n    achievesUnlocked: [] as string[],\n  }),\n  getters: {\n    knowPoints() {\n      let points = 0;\n      for (const id of this.achievesUnlocked) {\n        const matches = id.split(\"\");\n        const first = parseInt(matches[0]);\n        const second = parseInt(matches[1]);\n        points += ACHIEVEMENTS[first][second].bonus;\n      }\n      return points;\n    },\n    hasAchieve(store) {\n      return (row: number, col: number) => {\n        return store.achievesUnlocked.includes(getIdFromData(row, col));\n      };\n    },\n  },\n  actions: {\n    updateAchieves() {\n      for (const [rowNum, achieveRow] of ACHIEVEMENTS.entries()) {\n        for (const [aNum, achieve] of achieveRow.entries()) {\n          const token = getIdFromData(rowNum, aNum);\n          if (achieve.isUnlocked() && !this.hasAchieve(rowNum, aNum)) {\n            this.achievesUnlocked.push(token);\n          }\n        }\n      }\n    },\n  },\n});\n","import { defineStore, acceptHMRUpdate } from 'pinia';\nimport type { StateTree } from 'pinia';\nimport type {\n  GenericObjectType,\n  OneTimeSteamUpgradeType,\n  BasicType,\n} from './main/types';\nimport { getTime, copy, deepReplace, isObject } from './main/utils';\nimport { StatTracker } from './classes/trackers';\nimport { Upgrades } from './classes/upgrades';\nimport { Resource } from './classes/resource';\nimport LZString from 'lz-string';\nimport { useSteamStore } from './steam';\nimport { useTabsStore } from './tabs';\nimport { useNotificationStore } from './notifications';\nimport { useStatsStore } from './stats';\n\nconst ALL_STORES = {\n  steam: useSteamStore,\n  tabs: useTabsStore,\n  notify: useNotificationStore,\n  stats: useStatsStore,\n};\nexport const useStore = defineStore('main', {\n  state: () => ({\n    // modal stuff (but really small)\n    modal: '',\n    // notifications stuff\n    // other 'internal' stuff but should be split into the other stores\n    // to not use use[xxxx]Store for everything\n    keypresses: new Set<string>(),\n    internals: {\n      timestamp: getTime(),\n      rafID: 0,\n      fps: 0,\n      save: '',\n      lastSaveTimer: getTime(),\n    },\n\n    // too small for now to consider moving it to another store\n    settings: {\n      displayFPS: false,\n      maxFPS: 60,\n      saveInterval: 10000,\n    },\n  }),\n  getters: {\n    getSave(): string {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const replacer = function (key: string, data: any) {\n        if (['internals', 'modal'].includes(key)) return undefined;\n        // including those results that just include return for completeness\n        if (data instanceof StatTracker) {\n          return copy(data as unknown as GenericObjectType, ['resList'], false);\n        }\n        if (data instanceof Upgrades) {\n          return copy(data as unknown as GenericObjectType, ['level'], true);\n        }\n        if (data instanceof Resource) {\n          return data;\n        }\n        return data;\n      };\n      const save: { [key: string]: StateTree } = {\n        settings: {\n          ...this.settings,\n        },\n      };\n      Object.entries(REPLACE_PATH).forEach((entries) => {\n        save[entries[0]] = entries[1]().$state;\n      });\n      return LZString.compressToBase64(JSON.stringify(save, replacer));\n    },\n    getData: () => (layer: number) => {\n      switch (layer) {\n        case 1:\n          return useSteamStore();\n        default:\n          console.error('invalid layer: ' + layer);\n      }\n    },\n  },\n  actions: {\n    buyUpgrade(data: { name: string; layer: number; oneTime: boolean }) {\n      const layer = this.getData(data.layer);\n      function isOneUpgrades(\n        name: string,\n        upgs: OneTimeSteamUpgradeType\n      ): name is keyof OneTimeSteamUpgradeType {\n        return name in upgs;\n      }\n      if (layer === undefined) {\n        console.error('Invalid data.layer: ' + data.layer);\n      } else {\n        if (!data.oneTime) {\n          //upg.upgrades[data.name].buy();\n          console.error('No multi-buy steam upgrades');\n        } else if (isOneUpgrades(data.name, layer.oneUpgrades)) {\n          layer.oneUpgrades[data.name].buy();\n        }\n      }\n    },\n    init(load = true) {\n      const store = useSteamStore();\n      store.init();\n      if (load) {\n        this.loadSave();\n      }\n    },\n    updateGame(delta: number) {\n      const steam = useSteamStore();\n      steam.update(delta);\n    },\n    updateStats(timepassed: number) {\n      const statsStore = useStatsStore();\n      statsStore.totalTimePlayed += timepassed;\n      statsStore.updateAchieves();\n    },\n    updateExternal(timepassed: number) {\n      this.internals.fps = 1000 / timepassed;\n      this.updateStats(timepassed);\n      this.internals.timestamp = getTime();\n      this.updateSaveGameTick();\n      useNotificationStore().updateNotifications();\n    },\n    updateSaveGameTick() {\n      if (\n        getTime() - this.internals.lastSaveTimer >\n        this.settings.saveInterval\n      ) {\n        this.saveGame();\n        this.internals.lastSaveTimer = getTime();\n      }\n    },\n    hardReset() {\n      if (\n        !confirm(\n          'Are you sure to do this? This will wipe all of your progress!'\n        )\n      ) {\n        return;\n      }\n      this.$reset();\n      Object.values(ALL_STORES).forEach((store) => {\n        store().$reset();\n      });\n      useSteamStore().$reset();\n      this.init(false);\n      useNotificationStore().notify('Succesful hard reset.');\n    },\n    saveGame() {\n      localStorage.setItem('sgsave', this.getSave);\n      useNotificationStore().notify('Game saved.');\n    },\n    loadSave() {\n      /*const performSaveImport = (cache?: {\n        stack: Array<string | number>;\n        data: BasicType;\n      }) => {\n        if (typeof cache === 'undefined') {\n          let loadedSave = '';\n          const saveToImport = this.internals.save\n            ? this.internals.save\n            : localStorage.getItem('sgsave');\n          if (!saveToImport) return;\n          try {\n            loadedSave = JSON.parse(\n              LZString.decompressFromBase64(saveToImport) as string\n            );\n          } catch (e) {\n            // validation of save\n            console.error(e);\n            useNotificationStore().notify(\n              'An error occured while importing your save.'\n            );\n            return;\n          }\n          // this didn't happen but just in case\n          if (loadedSave === null) {\n            useNotificationStore().notify('Save is empty or is invalid.');\n            return;\n          }\n          performSaveImport({ stack: [], data: loadedSave });\n        } else if (typeof cache.data === 'object' && cache.data !== null) {\n          const toIter = Array.isArray(cache.data)\n            ? cache.data.entries()\n            : Object.entries(cache.data);\n          for (const [key, data] of toIter) {\n            const copyOfCache = cache.stack.slice();\n            copyOfCache.push(key);\n            performSaveImport({\n              stack: copyOfCache,\n              data: data,\n            });\n          }\n        } else {\n          let getString = '';\n          cache.stack.forEach((item) => {\n            const strToPut =\n              typeof item === 'number' ? `[${item}]` : `.${item}`;\n            getString += strToPut;\n          });\n          // a workaround for now\n          const inOthers = inRP(getString);\n          if (inOthers) {\n            getString = getString.replace(inOthers.text, '');\n            inOthers.obj().loadSaveFromString(getString, cache.data);\n          } else {\n            Function(\n              'state',\n              'data',\n              'state' + getString + '=data'\n            )(this, cache.data);\n          }\n        }\n      };\n      performSaveImport();*/\n      let loadedSave = {};\n      const saveToImport = this.internals.save\n        ? this.internals.save\n        : localStorage.getItem('sgsave');\n      if (!saveToImport) return;\n      try {\n        loadedSave = JSON.parse(\n          LZString.decompressFromBase64(saveToImport) || ''\n        );\n      } catch (e) {\n        // validation of save\n        console.error(e);\n        useNotificationStore().notify(\n          'An error occured while importing your save.'\n        );\n        return;\n      }\n      // this didn't happen but just in case\n      if (loadedSave === null) {\n        useNotificationStore().notify('Save is empty or is invalid.');\n        return;\n      }\n      deepReplace(\n        this,\n        loadedSave,\n        (obj: unknown, data: unknown, key: string) => {\n          const str = Object.keys(REPLACE_PATH).find((element) => {\n            return element === key;\n          }) as keyof typeof REPLACE_PATH;\n          //debugger\n          if (str !== undefined && isObject(data[key])) {\n            const dataNew = REPLACE_PATH[str]();\n            deepReplace(dataNew, data[key]);\n            console.log('new set');\n            return true;\n          }\n          console.log('set');\n          return false;\n        }\n      );\n      console.log(useSteamStore().water.owned);\n    },\n    mainGameLoop() {\n      const timepassed = getTime() - this.internals.timestamp;\n      if (timepassed > 1000 / this.settings.maxFPS) {\n        this.updateGame(timepassed);\n        this.updateExternal(timepassed);\n      }\n      this.internals.rafID = requestAnimationFrame(() => {\n        this.mainGameLoop();\n      });\n    },\n  },\n});\nexport const REPLACE_PATH = {\n  steam: useSteamStore,\n  stats: useStatsStore,\n};\n\nfunction isImportHot(hot: unknown): hot is Required<ImportMeta>['hot'] {\n  return typeof hot === 'object' && hot !== null && !Array.isArray(hot);\n}\nconst hot = import.meta.hot;\nif (hot && isImportHot(hot)) {\n  const hotModules = [...Object.values(ALL_STORES), useStore];\n  for (const md of hotModules) {\n    hot.accept(acceptHMRUpdate(md, import.meta.hot));\n  }\n  hot.accept((m) => {\n    if (!m.useSteamStore) return;\n    console.log('[dev]: hot reload steam.ts -> init');\n    // hot\n    useSteamStore().init();\n  });\n}\nexport { useSteamStore, useTabsStore, useNotificationStore, useStatsStore };\n","import { TABS } from \"./tabs\";\nimport { markRaw } from \"vue\";\nimport type { TabsType, LoreType } from \"./types\";\nconst getComputedTab = function <T extends { [key: string]: object }>(\n  tab: keyof T,\n  choices: T\n) {\n  return markRaw(choices[tab]);\n};\nconst getTab = function (tab: string) {\n  const val = TABS.find((_tab) => _tab.actual === tab);\n  if (val === undefined) {\n    throw new Error(`Invalid tab: ${tab}`);\n  }\n  return val;\n};\nconst getSubtabs = function (tab: string) {\n  const val = getTab(tab).subtabs;\n  if (val === undefined) {\n    throw new Error(`The tab does not have subtabs: ${tab}`);\n  }\n  return val;\n};\nconst getNextLore = function () {\n  let text = \"none\";\n  const lore = getTab(\"lore\") as TabsType & { lore: LoreType };\n  for (const loreItem of lore.lore) {\n    if (!loreItem.unlocked()) {\n      text = loreItem.textRequire;\n      break;\n    }\n  }\n  return text;\n};\nexport { getTab, getSubtabs, getNextLore, getComputedTab };\n","<template>\n  <div>\n    <span v-for=\"tab in tabList\" :key=\"tab.actual\">\n      <span v-if=\"tab.shown()\">\n        <span v-if=\"'subtabs' in tab\">\n          <button @click=\"changeTab(tab.actual)\">\n            {{ tab.display }}\n          </button>\n        </span>\n        <span v-else>\n          <button class=\"innertab\" @click=\"changeInnerTab(tab.actual)\">\n            {{ tab.display }}\n          </button>\n        </span>\n      </span>\n    </span>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useTabsStore } from \"@/stores/main\";\nimport type { TabsType, InnerTabsType } from \"@/stores/main/types\";\nimport type { TabOptionsType } from \"@/stores/main/tabTypes\";\ndefineProps<{\n  tabList: TabsType[] | InnerTabsType[];\n}>();\nconst changeTab = (tab: TabOptionsType) => {\n  useTabsStore().tab = tab;\n};\n\nconst changeInnerTab = (tab: string) => {\n  useTabsStore().changeInnerTab(tab);\n};\n</script>\n","\nexport default (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n}\n","<template>\n  <span v-if=\"upgrade.isUnlocked()\">\n    <button\n      :class=\"{ useable: !upgrade.isUnbuyable(), maxed: upgrade.isMaxLevel() }\"\n      :disabled=\"upgrade.isUnbuyable()\"\n      @click=\"buyUpgrade(upgData)\"\n    >\n      {{ upgrade.name }}\n      <br />{{ upgrade.desc }} <br />Cost: {{ upgrade.getPriceDisplay() }}\n      <div v-if=\"currentData.show\">Currently: {{ currentData.getBonus() }}</div>\n    </button>\n  </span>\n</template>\n<script setup lang=\"ts\">\nimport { useStore } from \"@/stores/main\";\nimport { computed } from \"vue\";\nimport type {\n  UpgradeType,\n  OneTimeUpgradeType,\n  UpgradeDataType,\n} from \"@/stores/main/types\";\nconst store = useStore();\nconst props = defineProps<{\n  upgId: string | number;\n  upgrade: UpgradeType | OneTimeUpgradeType;\n  oneTime: boolean;\n  currentData: UpgradeDataType;\n}>();\nconst buyUpgrade = (obj: { name: string; layer: number; oneTime: boolean }) => {\n  store.buyUpgrade(obj);\n};\nconst upgData = computed(() => {\n  return {\n    name: props.upgId as string,\n    layer: props.upgrade.layer,\n    oneTime: props.oneTime,\n  };\n});\n</script>\n<style scoped>\n.maxed {\n  background: #1fad1f;\n}\n</style>\n","<template>\n  <div>\n    <div>You have {{ displayNumber(store.water.owned) }} water.</div>\n    <button\n      :class=\"{ useable: isUseable('fill') }\"\n      @click=\"getResource('fill')\"\n    >\n      Fill the furnace\n    </button>\n    <button\n      :class=\"{ useable: isUseable('heat') }\"\n      @click=\"getResource('heat')\"\n    >\n      Heat the furnace\n    </button>\n    <button\n      :class=\"{ useable: isUseable('water') }\"\n      @click=\"getResource('water')\"\n    >\n      Get 1 Water\n    </button>\n    <div>\n      Heat in furnace: {{ displayNumber(store.heat.owned) }}/{{\n        displayNumber(store.heat.queueData.req)\n      }}<br />\n      Water in furnace: {{ displayNumber(store.fill.owned) }}/{{\n        displayNumber(store.fill.queueData.req)\n      }}\n    </div>\n    <!--<upgrade-button\n      v-for=\"(upgrade, i) in steam.upgrades\"\n      :key=\"upgrade.name\"\n      :upgrade=\"upgrade\"\n      :upg-id=\"i\"\n      :one-time=\"false\"\n    />-->\n    <div>Upgrades:</div>\n    <upgrade-button\n      v-for=\"(upgrade, i) in store.oneUpgrades\"\n      :key=\"upgrade.name\"\n      :upgrade=\"upgrade\"\n      :upg-id=\"i\"\n      :one-time=\"true\"\n      :current-data=\"upgrade.data\"\n    />\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useSteamStore } from \"@/stores/main\";\nimport UpgradeButton from \"../generic/UpgradeButton.vue\";\nimport { displayNumber } from \"@/stores/main/utils\";\nimport type { SteamResourceType } from \"@/stores/main/types\";\nconst store = useSteamStore();\nconst isUseable = (otherRes: SteamResourceType) => store.isUseable(otherRes);\nconst getResource = (res: SteamResourceType) => {\n  store.getResource(res);\n};\n</script>\n","<template>\n  <div class=\"tab-display\">\n    <br />\n    <tabs-view :tab-list=\"tabs\" />\n    <component :is=\"innerTab\" />\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { getSubtabs, getComputedTab } from \"@/stores/main/compUtils\";\nimport { useTabsStore } from \"@/stores/main\";\nimport { computed } from \"vue\";\nimport type { BUSINESS_TAB_LIST_TYPE } from \"@/stores/main/tabTypes\";\nimport TabsView from \"../generic/TabsView.vue\";\nimport SteamSubtab from \"../subtabs/SteamSubtab.vue\";\nimport WorkerSubtab from \"../subtabs/WorkerSubtab.vue\";\nconst tabs = getSubtabs(\"business\");\nconst TABS_LIST: BUSINESS_TAB_LIST_TYPE = {\n  workers: WorkerSubtab,\n  steam: SteamSubtab,\n};\nconst innerTab = computed(() =>\n  getComputedTab(useTabsStore().innerTabs.business, TABS_LIST)\n);\n</script>\n","<template>\n  <div class=\"business-display\">\n    <span>\n      <span v-if=\"shown\"> FPS: {{ displayNumber(actFPS, 0, true) }} </span>\n      <span v-else class=\"hide\"> FPS: 60 </span>\n    </span>\n    <span> You currently have {{ steam.owned }} steam. </span>\n    <span class=\"hide\"> FPS: 60 </span>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useStore, useSteamStore } from \"@/stores/main\";\nimport { displayNumber } from \"@/stores/main/utils\";\nimport { computed } from \"vue\";\nconst steamStore = useSteamStore();\nconst store = useStore();\nconst steam = computed(() => steamStore.steam);\nconst actFPS = computed(() => store.internals.fps);\nconst shown = computed(() => store.settings.displayFPS);\n</script>\n<style scoped>\n.business-display {\n  display: flex;\n  justify-content: space-between;\n}\n</style>\n","<template>\n  <div class=\"tab-display\">\n    You have made a total of\n    {{ tracked.steam.totalMade }} steam.<br />\n    You have been playing for\n    {{ prettyTimeAsTotal(statsStore.totalTimePlayed) }}.\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useStatsStore, useSteamStore } from \"@/stores/main\";\nimport { prettyTimeAsTotal } from \"@/stores/main/utils\";\nconst steamStore = useSteamStore();\nconst statsStore = useStatsStore();\nconst tracked = steamStore.statTracker.resources;\n</script>\n","<template>\n  <div class=\"tab-display\">\n    <span v-for=\"loreItem in lore\" :key=\"loreItem.textRequire\">\n      <div v-if=\"loreItem.unlocked()\">\n        {{ loreItem.text }}\n      </div>\n    </span>\n    <br />\n    <br />\n    <br />\n    <div>Unlock next lore requirement: {{ getNextLore() }}</div>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { getTab, getNextLore } from \"@/stores/main/compUtils\";\nconst lore = getTab(\"lore\").lore;\n</script>\n","<template>\n  <div class=\"options style-as-button\">\n    {{ data.display() }}<br />\n    <input\n      v-model=\"result\"\n      type=\"range\"\n      :min=\"data.other.min\"\n      :max=\"data.other.max\"\n    />\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { computed } from \"vue\";\nimport type { SettingButtonInputType } from \"@/stores/main/types\";\nconst props = defineProps<{\n  data: SettingButtonInputType;\n}>();\nconst result = computed({\n  get: () => props.data.other.getValue(),\n  set(value: number) {\n    props.data.doInput(props.data.other.result(value));\n  },\n});\n</script>\n<style scoped>\n.options {\n  height: 50px;\n  width: 160px;\n}\n</style>\n","<template>\n  <div>\n    <textarea\n      v-model=\"save\"\n      rows=\"4\"\n      cols=\"150\"\n      style=\"width: 100%\"\n      placeholder=\"This is your exported save. Keep it safe in case your save gets lost!\"\n    /><br />\n    <table class=\"center\">\n      <!-- :key=\"i\": unsafe key -->\n      <tr v-for=\"(btnRow, i) in btns\" :key=\"i\">\n        <!-- :key=\"s\": unsafe key -->\n        <td v-for=\"(innerRow, s) in btnRow\" :key=\"s\">\n          <div v-if=\"innerRow === undefined\"></div>\n          <setting-input-button\n            v-else-if=\"innerRow.type === 'input'\"\n            :data=\"innerRow\"\n          />\n          <setting-button\n            v-else-if=\"innerRow.type === 'button'\"\n            :data=\"innerRow\"\n          />\n        </td>\n      </tr>\n    </table>\n  </div>\n</template>\n<script setup lang=\"ts\">\n// @unsafe key\nimport SettingButton from \"../generic/SettingButton.vue\";\nimport SettingInputButton from \"../generic/SettingButtonInput.vue\";\nimport { getTab } from \"@/stores/main/compUtils\";\nimport { computed } from \"vue\";\nimport { useStore } from \"@/stores/main\";\nconst store = useStore();\nconst btns = getTab(\"options\").buttons;\nconst save = computed({\n  get: () => store.internals.save,\n  set: (save: string) => {\n    store.internals.save = save;\n  },\n});\n</script>\n","<template>\n  <div class=\"tab-display\">\n    <br />\n    <tabs-view :tab-list=\"tabs\" />\n    <component :is=\"innerTab\" />\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useTabsStore } from \"@/stores/main\";\nimport { computed } from \"vue\";\nimport TabsView from \"../generic/TabsView.vue\";\nimport SettingsSubtab from \"../subtabs/SettingsSubtab.vue\";\nimport AboutSubtab from \"../subtabs/AboutSubtab.vue\";\nimport ChangelogSubtab from \"../subtabs/ChangelogSubtab.vue\";\nimport type { OPTIONS_TAB_LIST_TYPE } from \"@/stores/main/tabTypes\";\nimport { getSubtabs, getComputedTab } from \"@/stores/main/compUtils\";\nconst TABS_LIST: OPTIONS_TAB_LIST_TYPE = {\n  settings: SettingsSubtab,\n  about: AboutSubtab,\n  changelog: ChangelogSubtab,\n};\nconst innerTab = computed(() =>\n  getComputedTab(useTabsStore().innerTabs.options, TABS_LIST)\n);\nconst tabs = getSubtabs(\"options\");\n</script>\n","<template>\n  <div class=\"tab-display\">\n    <br />\n    <br />\n    You have {{ points }} knowledge points, which multiply motivation's effect\n    by {{ points + 1 }}.\n    <table class=\"center\">\n      <!-- :key=\"rowId\": unsafe key -->\n      <tr v-for=\"(achieveRow, rowId) in achieves\" :key=\"rowId\">\n        <!-- :key=\"aId\": unsafe key -->\n        <td\n          v-for=\"(achieve, aId) in achieveRow\"\n          :key=\"aId\"\n          class=\"style-as-button achieve tooltip\"\n          :style=\"{ 'background-color': isUnlocked(rowId, aId) }\"\n        >\n          <span>{{ achieve.desc }}</span>\n          <span class=\"tooltiptext\">{{ achieve.hoverText }}</span>\n        </td>\n      </tr>\n    </table>\n  </div>\n</template>\n<script setup lang=\"ts\">\n// @unsafe key\nimport { ACHIEVEMENTS } from \"@/stores/main/tabs\";\nimport { useStatsStore } from \"@/stores/main\";\nimport { computed } from \"vue\";\nconst store = useStatsStore();\nconst achieves = ACHIEVEMENTS;\nconst points = computed(() => store.knowPoints);\nconst isUnlocked = (rowId: number, colId: number) => {\n  return store.hasAchieve(rowId, colId) ? \"#00FF00\" : \"#FFFFFF\";\n};\n</script>\n<style scoped>\n.achieve {\n  vertical-align: top;\n  text-align: center;\n  font-size: 0.875rem;\n  width: 128px;\n  height: 128px;\n  padding: 4px;\n  border: solid;\n  border-width: 1px 1px;\n}\n</style>\n","<template>\n  <div class=\"notificationarea\">\n    <div\n      v-for=\"(notify, i) in notifications\"\n      :key=\"notify.time\"\n      class=\"notification\"\n      @click=\"removeNotify(i)\"\n    >\n      {{ notify.text }}\n    </div>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useNotificationStore } from \"@/stores/main\";\nimport { computed } from \"vue\";\nconst store = useNotificationStore();\nconst notifications = computed(() => store.notifications.slice().reverse());\nconst removeNotify = (i: number) => {\n  store.removeNotify(i);\n};\n</script>\n<style scoped>\n.notificationarea {\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  z-index: 1;\n}\n.notification {\n  position: relative;\n  right: 0px;\n  margin: 0px;\n  padding: 2px;\n  background-color: #000000;\n  color: #ffffff;\n  text-align: center;\n  border-radius: 6px;\n  z-index: 1;\n}\n</style>\n","<template>\n  <div v-if=\"modal\" class=\"modal\" @click=\"closeModalHandler\">\n    <!-- Modal content -->\n    <div class=\"modal-content\">\n      <span class=\"close\" @click=\"closeModal\">&times;</span>\n      <component :is=\"modal\" />\n    </div>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useStore } from \"@/stores/main\";\nimport { computed } from \"vue\";\n//import { getComputedTab } from '../../stores/main/compUtils';\nconst store = useStore();\nconst modal = computed((): null | object => {\n  if (store.modal !== \"\") {\n    throw new Error(\"modals do not exist\");\n    //return getComputedTab(store.modal, {});\n  }\n  return null;\n});\nconst closeModal = function () {\n  store.modal = \"\";\n};\nconst closeModalHandler = function (e: MouseEvent) {\n  if ((e.target as Element).className === \"modal\") {\n    closeModal();\n  }\n};\n</script>\n<style scoped>\n.modal {\n  position: fixed; /* Stay in place */\n  z-index: 1; /* Sit on top */\n  left: 0;\n  top: 0;\n  width: 100%; /* Full width */\n  height: 100%; /* Full height */\n  overflow: auto; /* Enable scroll if needed */\n  background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */\n}\n.modal-content {\n  position: relative;\n  background-color: #fefefe;\n  margin: 15% auto; /* 15% from the top and centered */\n  padding: 20px;\n  border: 1px solid #888;\n  width: 80%; /* Could be more or less, depending on screen size */\n}\n.close {\n  position: absolute;\n  top: 0;\n  right: 10px;\n  color: #aaa;\n  font-size: 28px;\n  font-weight: bold;\n}\n\n.close:hover,\n.close:focus {\n  color: black;\n  text-decoration: none;\n  cursor: pointer;\n}\n</style>\n","<template>\n  <div>\n    <display-view />\n    <tab-display />\n    <notification-view />\n    <modal-view />\n    <component :is=\"tab\"></component>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport BusinessTab from \"./components/main/BusinessTab.vue\";\nimport DisplayView from \"./components/main/DisplayView.vue\";\nimport TabDisplay from \"./components/main/TabDisplay.vue\";\nimport StatsTab from \"./components/main/StatsTab.vue\";\nimport LoreTab from \"./components/main/LoreTab.vue\";\nimport OptionsTab from \"./components/main/OptionsTab.vue\";\nimport AchieveTab from \"./components/main/AchieveTab.vue\";\nimport NotificationView from \"./components/main/NotificationView.vue\";\nimport ModalView from \"./components/main/ModalView.vue\";\nimport { useStore, useTabsStore } from \"./stores/main\";\nimport { getComputedTab } from \"./stores/main/compUtils\";\nimport type { MAIN_TAB_LIST_TYPE } from \"./stores/main/tabTypes\";\nimport { onMounted, onBeforeUnmount, computed } from \"vue\";\nconst store = useStore();\nconst TAB_LIST: MAIN_TAB_LIST_TYPE = {\n  business: BusinessTab,\n  stats: StatsTab,\n  lore: LoreTab,\n  achieve: AchieveTab,\n  options: OptionsTab,\n};\nonMounted(() => {\n  store.init();\n  store.mainGameLoop();\n});\nconst tab = computed(() => getComputedTab(useTabsStore().tab, TAB_LIST));\nonBeforeUnmount(() => {\n  cancelAnimationFrame(store.internals.rafID);\n});\n</script>\n<style>\n/* *** All components styling *** */\n* {\n  box-sizing: border-box;\n}\nbutton {\n  font-family: inherit;\n  font-size: 100%;\n  background: #ffffff;\n  border: 1px solid #000000;\n  box-sizing: border-box;\n  border-radius: 4px;\n  padding: 0.5rem 1rem;\n  transition: 500ms;\n}\n\n/* Specific tabs */\n.innertab {\n  padding: 0.25rem 1rem;\n}\n.tab-display {\n  text-align: center;\n}\n/* Generic styles */\n.center {\n  text-align: center;\n}\n/* For mainly upgrades, but can also be used for other things */\n.useable {\n  background: #00ff00;\n}\n.useable:hover {\n  transform: scale(1.1);\n}\n.hide {\n  visibility: hidden;\n}\n.style-as-button {\n  font-family: inherit;\n  font-size: 100%;\n  background: #ffffff;\n  border: 0.1px solid #000000;\n  box-sizing: border-box;\n  border-radius: 4px;\n  transition: 500ms;\n}\n/* Overides default center class for tables */\ntable.center {\n  margin-left: auto;\n  margin-right: auto;\n}\n\n/* Tooltips. Note: these can be extended. */\n/* Tooltip container */\n.tooltip {\n  position: relative;\n  display: inline-block;\n}\n\n/* Tooltip text */\n.tooltip .tooltiptext {\n  /* Important detail, will be shown on hover */\n  visibility: hidden;\n\n  /* By default */\n  text-align: center;\n  padding: 5px 0;\n  border-radius: 6px;\n\n  /* Used to position the tooltip */\n  position: absolute;\n  z-index: 1;\n\n  /* ****** How it looks ********* */\n  background-color: grey;\n  color: #ffffff;\n\n  /* ****** Show tooltip on top ******* */\n  width: 120px;\n  bottom: 100%;\n  left: 50%;\n  margin-left: -60px;\n}\n\n/* Show the tooltip text when you mouse over the tooltip container */\n.tooltip:hover .tooltiptext {\n  visibility: visible;\n}\n</style>\n","import { createApp } from \"vue\";\nimport { createPinia } from \"pinia\";\nimport { useStore } from \"./stores/main\";\nimport App from \"./App.vue\";\n\ncreateApp(App).use(createPinia()).mount(\"#app\");\nwindow.addEventListener(\"keydown\", (e) => {\n  const store = useStore();\n  if (!store.keypresses.has(e.key)) {\n    store.keypresses.add(e.key);\n  }\n});\nwindow.addEventListener(\"keyup\", (e) => {\n  const store = useStore();\n  store.keypresses.delete(e.key);\n});\nwindow.addEventListener(\"visibilitychange\", () => {\n  const store = useStore();\n  store.keypresses.clear();\n});\n"],"names":["defaultQueue","BS","OS","SteamSubtab","SettingsSubtab","BusinessTab","StatsTab","LoreTab","OptionsTab","App"],"mappings":"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"}